LIBARCHIVE(3)            BSD Library Functions Manual            LIBARCHIVE(3)

NNAAMMEE
     lliibbaarrcchhiivvee -- functions for reading and writing streaming archives

OOVVEERRVVIIEEWW
     The lliibbaarrcchhiivvee library provides a flexible interface for reading and
     writing archives in various formats such as tar and cpio.  lliibbaarrcchhiivvee
     also supports reading and writing archives compressed using various com-
     pression filters such as gzip and bzip2.  The library is inherently
     stream-oriented; readers serially iterate through the archive, writers
     serially add things to the archive.  In particular, note that there is
     currently no built-in support for random access nor for in-place modifi-
     cation.

     When reading an archive, the library automatically detects the format and
     the compression.  The library currently has read support for:
     ++oo   old-style tar archives,
     ++oo   most variants of the POSIX ``ustar'' format,
     ++oo   the POSIX ``pax interchange'' format,
     ++oo   GNU-format tar archives,
     ++oo   most common cpio archive formats,
     ++oo   ISO9660 CD images (including RockRidge and Joliet extensions),
     ++oo   Zip archives,
     ++oo   ar archives (including GNU/SysV and BSD extensions),
     ++oo   Microsoft CAB archives,
     ++oo   LHA archives,
     ++oo   mtree file tree descriptions,
     ++oo   RAR archives,
     ++oo   XAR archives.
     The library automatically detects archives compressed with gzip(1),
     bzip2(1), xz(1), lzip(1), or compress(1) and decompresses them transpar-
     ently.  It can similarly detect and decode archives processed with
     uuencode(1) or which have an rpm(1) header.

     When writing an archive, you can specify the compression to be used and
     the format to use.  The library can write
     ++oo   POSIX-standard ``ustar'' archives,
     ++oo   POSIX ``pax interchange format'' archives,
     ++oo   POSIX octet-oriented cpio archives,
     ++oo   Zip archive,
     ++oo   two different variants of shar archives,
     ++oo   ISO9660 CD images,
     ++oo   7-Zip archives,
     ++oo   ar archives,
     ++oo   mtree file tree descriptions,
     ++oo   XAR archives.
     Pax interchange format is an extension of the tar archive format that
     eliminates essentially all of the limitations of historic tar formats in
     a standard fashion that is supported by POSIX-compliant pax(1) implemen-
     tations on many systems as well as several newer implementations of
     tar(1).  Note that the default write format will suppress the pax
     extended attributes for most entries; explicitly requesting pax format
     will enable those attributes for all entries.

     The read and write APIs are accessed through the aarrcchhiivvee__rreeaadd__XXXXXX() func-
     tions and the aarrcchhiivvee__wwrriittee__XXXXXX() functions, respectively, and either can
     be used independently of the other.

     The rest of this manual page provides an overview of the library opera-
     tion.  More detailed information can be found in the individual manual
     pages for each API or utility function.

RREEAADDIINNGG AANN AARRCCHHIIVVEE
     See archive_read(3).

WWRRIITTIINNGG AANN AARRCCHHIIVVEE
     See archive_write(3).

WWRRIITTIINNGG EENNTTRRIIEESS TTOO DDIISSKK
     The archive_write_disk(3) API allows you to write archive_entry(3)
     objects to disk using the same API used by archive_write(3).  The
     archive_write_disk(3) API is used internally by aarrcchhiivvee__rreeaadd__eexxttrraacctt();
     using it directly can provide greater control over how entries get writ-
     ten to disk.  This API also makes it possible to share code between ar-
     chive-to-archive copy and archive-to-disk extraction operations.

RREEAADDIINNGG EENNTTRRIIEESS FFRROOMM DDIISSKK
     The archive_read_disk(3) supports for populating archive_entry(3) objects
     from information in the filesystem.  This includes the information acces-
     sible from the stat(2) system call as well as ACLs, extended attributes,
     and other metadata.  The archive_read_disk(3) API also supports iterating
     over directory trees, which allows directories of files to be read using
     an API compatible with the archive_read(3) API.

DDEESSCCRRIIPPTTIIOONN
     Detailed descriptions of each function are provided by the corresponding
     manual pages.

     All of the functions utilize an opaque struct archive datatype that pro-
     vides access to the archive contents.

     The struct archive_entry structure contains a complete description of a
     single archive entry.  It uses an opaque interface that is fully docu-
     mented in archive_entry(3).

     Users familiar with historic formats should be aware that the newer vari-
     ants have eliminated most restrictions on the length of textual fields.
     Clients should not assume that filenames, link names, user names, or
     group names are limited in length.  In particular, pax interchange format
     can easily accommodate pathnames in arbitrary character sets that exceed
     _P_A_T_H___M_A_X.

RREETTUURRNN VVAALLUUEESS
     Most functions return AARRCCHHIIVVEE__OOKK (zero) on success, non-zero on error.
     The return value indicates the general severity of the error, ranging
     from AARRCCHHIIVVEE__WWAARRNN, which indicates a minor problem that should probably
     be reported to the user, to AARRCCHHIIVVEE__FFAATTAALL, which indicates a serious
     problem that will prevent any further operations on this archive.  On
     error, the aarrcchhiivvee__eerrrrnnoo() function can be used to retrieve a numeric
     error code (see errno(2)).  The aarrcchhiivvee__eerrrroorr__ssttrriinngg() returns a textual
     error message suitable for display.

     aarrcchhiivvee__rreeaadd__nneeww() and aarrcchhiivvee__wwrriittee__nneeww() return pointers to an allo-
     cated and initialized struct archive object.

     aarrcchhiivvee__rreeaadd__ddaattaa() and aarrcchhiivvee__wwrriittee__ddaattaa() return a count of the number
     of bytes actually read or written.  A value of zero indicates the end of
     the data for this entry.  A negative value indicates an error, in which
     case the aarrcchhiivvee__eerrrrnnoo() and aarrcchhiivvee__eerrrroorr__ssttrriinngg() functions can be used
     to obtain more information.

EENNVVIIRROONNMMEENNTT
     There are character set conversions within the archive_entry(3) functions
     that are impacted by the currently-selected locale.

SSEEEE AALLSSOO
     tar(1), archive_entry(3), archive_read(3), archive_util(3),
     archive_write(3), tar(5)

HHIISSTTOORRYY
     The lliibbaarrcchhiivvee library first appeared in FreeBSD 5.3.

AAUUTTHHOORRSS
     The lliibbaarrcchhiivvee library was originally written by Tim Kientzle
     <kientzle@acm.org>.

BBUUGGSS
     Some archive formats support information that is not supported by struct
     archive_entry.  Such information cannot be fully archived or restored
     using this library.  This includes, for example, comments, character
     sets, or the arbitrary key/value pairs that can appear in pax interchange
     format archives.

     Conversely, of course, not all of the information that can be stored in
     an struct archive_entry is supported by all formats.  For example, cpio
     formats do not support nanosecond timestamps; old tar formats do not sup-
     port large device numbers.

     The ISO9660 reader cannot yet read all ISO9660 images; it should learn
     how to seek.

     The AR writer requires the client program to use two passes, unlike all
     other libarchive writers.

BSD                             March 18, 2012                             BSD
