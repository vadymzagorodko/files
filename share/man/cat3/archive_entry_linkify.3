ARCHIVE_ENTRY_LINKIFY(3) BSD Library Functions Manual ARCHIVE_ENTRY_LINKIFY(3)

NNAAMMEE
     aarrcchhiivvee__eennttrryy__lliinnkkrreessoollvveerr, aarrcchhiivvee__eennttrryy__lliinnkkrreessoollvveerr__nneeww,
     aarrcchhiivvee__eennttrryy__lliinnkkrreessoollvveerr__sseett__ssttrraatteeggyy, aarrcchhiivvee__eennttrryy__lliinnkkrreessoollvveerr__ffrreeee,
     aarrcchhiivvee__eennttrryy__lliinnkkiiffyy -- hardlink resolver functions

LLIIBBRRAARRYY
     Streaming Archive Library (libarchive, -larchive)

SSYYNNOOPPSSIISS
     ##iinncclluuddee <<aarrcchhiivvee__eennttrryy..hh>>

     _s_t_r_u_c_t _a_r_c_h_i_v_e___e_n_t_r_y___l_i_n_k_r_e_s_o_l_v_e_r _*
     aarrcchhiivvee__eennttrryy__lliinnkkrreessoollvveerr__nneeww(_v_o_i_d);

     _v_o_i_d
     aarrcchhiivvee__eennttrryy__lliinnkkrreessoollvveerr__sseett__ssttrraatteeggyy(_s_t_r_u_c_t _a_r_c_h_i_v_e___e_n_t_r_y___l_i_n_k_r_e_s_o_l_v_e_r _*_r_e_s_o_l_v_e_r,
         _i_n_t _f_o_r_m_a_t);

     _v_o_i_d
     aarrcchhiivvee__eennttrryy__lliinnkkrreessoollvveerr__ffrreeee(_s_t_r_u_c_t _a_r_c_h_i_v_e___e_n_t_r_y___l_i_n_k_r_e_s_o_l_v_e_r _*_r_e_s_o_l_v_e_r);

     _v_o_i_d
     aarrcchhiivvee__eennttrryy__lliinnkkiiffyy(_s_t_r_u_c_t _a_r_c_h_i_v_e___e_n_t_r_y___l_i_n_k_r_e_s_o_l_v_e_r _*_r_e_s_o_l_v_e_r,
         _s_t_r_u_c_t _a_r_c_h_i_v_e___e_n_t_r_y _*_*_e_n_t_r_y, _s_t_r_u_c_t _a_r_c_h_i_v_e___e_n_t_r_y _*_*_s_p_a_r_s_e);

DDEESSCCRRIIPPTTIIOONN
     Programs that want to create archives have to deal with hardlinks.
     Hardlinks are handled in different ways by the archive formats.  The
     basic strategies are:

     1.   Ignore hardlinks and store the body for each reference (old cpio,
          zip).

     2.   Store the body the first time an inode is seen (ustar, pax).

     3.   Store the body the last time an inode is seen (new cpio).

     The aarrcchhiivvee__eennttrryy__lliinnkkrreessoollvveerr functions help by providing a unified
     interface and handling the complexity behind the scene.

     The aarrcchhiivvee__eennttrryy__lliinnkkrreessoollvveerr functions assume that _a_r_c_h_i_v_e___e_n_t_r_y
     instances have valid nlinks, inode and device values.  The inode and
     device value is used to match entries.  The nlinks value is used to
     determined if all references have been found and if the internal refer-
     ences can be recycled.

     The aarrcchhiivvee__eennttrryy__lliinnkkrreessoollvveerr__nneeww() function allocates a new link
     resolver.  The instance can be freed using
     aarrcchhiivvee__eennttrryy__lliinnkkrreessoollvveerr__ffrreeee().  All deferred entries are flushed and
     the internal storage is freed.

     The aarrcchhiivvee__eennttrryy__lliinnkkrreessoollvveerr__sseett__ssttrraatteeggyy() function selects the opti-
     mal hardlink strategy for the given format.  The format code can be
     obtained from archive_format(3).  The function can be called more than
     once, but it is recommended to flush all deferred entries first.

     The aarrcchhiivvee__eennttrryy__lliinnkkiiffyy() function is the core of
     aarrcchhiivvee__eennttrryy__lliinnkkrreessoollvveerr.  The eennttrryy() argument points to the
     _a_r_c_h_i_v_e___e_n_t_r_y that should be written.  Depending on the strategy one of
     the following actions is taken:

     1.   For the simple archive formats _*_e_n_t_r_y is left unmodified and _*_s_p_a_r_s_e
          is set to NULL.

     2.   For tar like archive formats, _*_s_p_a_r_s_e is set to NULL.  If _*_e_n_t_r_y is
          NULL, no action is taken.  If the hardlink count of _*_e_n_t_r_y is larger
          than 1 and the file type is a regular file or symbolic link, the
          internal list is searched for a matching inode.  If such an inode is
          found, the link count is decremented and the file size of _*_e_n_t_r_y is
          set to 0 to notify that no body should be written.  If no such inode
          is found, a copy of the entry is added to the internal cache with a
          link count reduced by one.

     3.   For new cpio like archive formats a value for _*_e_n_t_r_y of NULL is used
          to flush deferred entries.  In that case _*_e_n_t_r_y is set to an arbi-
          trary deferred entry and the entry itself is removed from the inter-
          nal list.  If the internal list is empty, _*_e_n_t_r_y is set to NULL.  In
          either case, _*_s_p_a_r_s_e is set to NULL and the function returns.  If
          the hardlink count of _*_e_n_t_r_y is one or the file type is a directory
          or device, _*_s_p_a_r_s_e is set to NULL and no further action is taken.
          Otherwise, the internal list is searched for a matching inode.  If
          such an inode is not found, the entry is added to the internal list,
          both _*_e_n_t_r_y and _*_s_p_a_r_s_e are set to NULL and the function returns.
          If such an inode is found, the link count is decremented.  If it
          remains larger than one, the existing entry on the internal list is
          swapped with _*_e_n_t_r_y after retaining the link count.  The existing
          entry is returned in _*_e_n_t_r_y.  If the link count reached one, the new
          entry is also removed from the internal list and returned in
          _*_s_p_a_r_s_e.  Otherwise _*_s_p_a_r_s_e is set to NULL.

     The general usage is therefore:

     1.   For each new archive entry, call aarrcchhiivvee__eennttrryy__lliinnkkiiffyy().

     2.   Keep in mind that the entries returned may have a size of 0 now.

     3.   If _*_e_n_t_r_y is not NULL, archive it.

     4.   If _*_s_p_a_r_s_e is not NULL, archive it.

     5.   After all entries have been written to disk, call
          aarrcchhiivvee__eennttrryy__lliinnkkiiffyy() with _*_e_n_t_r_y set to NULL and archive the
          returned entry as long as it is not NULL.

RREETTUURRNN VVAALLUUEESS
     aarrcchhiivvee__eennttrryy__lliinnkkrreessoollvveerr__nneeww() returns NULL on malloc(3) failures.

SSEEEE AALLSSOO
     archive_entry(3)

BSD                            February 2, 2012                            BSD
