ARCHIVE_WRITE_DISK(3)    BSD Library Functions Manual    ARCHIVE_WRITE_DISK(3)

NNAAMMEE
     aarrcchhiivvee__wwrriittee__ddiisskk__nneeww, aarrcchhiivvee__wwrriittee__ddiisskk__sseett__ooppttiioonnss,
     aarrcchhiivvee__wwrriittee__ddiisskk__sseett__sskkiipp__ffiillee, aarrcchhiivvee__wwrriittee__ddiisskk__sseett__ggrroouupp__llooookkuupp,
     aarrcchhiivvee__wwrriittee__ddiisskk__sseett__ssttaannddaarrdd__llooookkuupp,
     aarrcchhiivvee__wwrriittee__ddiisskk__sseett__uusseerr__llooookkuupp, aarrcchhiivvee__wwrriittee__hheeaaddeerr,
     aarrcchhiivvee__wwrriittee__ddaattaa, aarrcchhiivvee__wwrriittee__ddaattaa__bblloocckk, aarrcchhiivvee__wwrriittee__ffiinniisshh__eennttrryy,
     aarrcchhiivvee__wwrriittee__cclloossee, aarrcchhiivvee__wwrriittee__ffiinniisshh aarrcchhiivvee__wwrriittee__ffrreeee -- functions
     for creating objects on disk

LLIIBBRRAARRYY
     Streaming Archive Library (libarchive, -larchive)

SSYYNNOOPPSSIISS
     ##iinncclluuddee <<aarrcchhiivvee..hh>>

     _s_t_r_u_c_t _a_r_c_h_i_v_e _*
     aarrcchhiivvee__wwrriittee__ddiisskk__nneeww(_v_o_i_d);

     _i_n_t
     aarrcchhiivvee__wwrriittee__ddiisskk__sseett__ooppttiioonnss(_s_t_r_u_c_t _a_r_c_h_i_v_e _*, _i_n_t _f_l_a_g_s);

     _i_n_t
     aarrcchhiivvee__wwrriittee__ddiisskk__sseett__sskkiipp__ffiillee(_s_t_r_u_c_t _a_r_c_h_i_v_e _*, _d_e_v___t, _i_n_o___t);

     _i_n_t
     aarrcchhiivvee__wwrriittee__ddiisskk__sseett__ggrroouupp__llooookkuupp(_s_t_r_u_c_t _a_r_c_h_i_v_e _*, _v_o_i_d _*,
         _g_i_d___t _(_*_)_(_v_o_i_d _*_, _c_o_n_s_t _c_h_a_r _*_g_n_a_m_e_, _g_i_d___t _g_i_d_),
         _v_o_i_d _(_*_c_l_e_a_n_u_p_)_(_v_o_i_d _*_));

     _i_n_t
     aarrcchhiivvee__wwrriittee__ddiisskk__sseett__ssttaannddaarrdd__llooookkuupp(_s_t_r_u_c_t _a_r_c_h_i_v_e _*);

     _i_n_t
     aarrcchhiivvee__wwrriittee__ddiisskk__sseett__uusseerr__llooookkuupp(_s_t_r_u_c_t _a_r_c_h_i_v_e _*, _v_o_i_d _*,
         _u_i_d___t _(_*_)_(_v_o_i_d _*_, _c_o_n_s_t _c_h_a_r _*_u_n_a_m_e_, _u_i_d___t _u_i_d_),
         _v_o_i_d _(_*_c_l_e_a_n_u_p_)_(_v_o_i_d _*_));

     _i_n_t
     aarrcchhiivvee__wwrriittee__hheeaaddeerr(_s_t_r_u_c_t _a_r_c_h_i_v_e _*, _s_t_r_u_c_t _a_r_c_h_i_v_e___e_n_t_r_y _*);

     _l_a___s_s_i_z_e___t
     aarrcchhiivvee__wwrriittee__ddaattaa(_s_t_r_u_c_t _a_r_c_h_i_v_e _*, _c_o_n_s_t _v_o_i_d _*, _s_i_z_e___t);

     _l_a___s_s_i_z_e___t
     aarrcchhiivvee__wwrriittee__ddaattaa__bblloocckk(_s_t_r_u_c_t _a_r_c_h_i_v_e _*, _c_o_n_s_t _v_o_i_d _*, _s_i_z_e___t _s_i_z_e,
         _i_n_t_6_4___t _o_f_f_s_e_t);

     _i_n_t
     aarrcchhiivvee__wwrriittee__ffiinniisshh__eennttrryy(_s_t_r_u_c_t _a_r_c_h_i_v_e _*);

     _i_n_t
     aarrcchhiivvee__wwrriittee__cclloossee(_s_t_r_u_c_t _a_r_c_h_i_v_e _*);

     _i_n_t
     aarrcchhiivvee__wwrriittee__ffiinniisshh(_s_t_r_u_c_t _a_r_c_h_i_v_e _*);

     _i_n_t
     aarrcchhiivvee__wwrriittee__ffrreeee(_s_t_r_u_c_t _a_r_c_h_i_v_e _*);

DDEESSCCRRIIPPTTIIOONN
     These functions provide a complete API for creating objects on disk from
     struct archive_entry descriptions.  They are most naturally used when
     extracting objects from an archive using the aarrcchhiivvee__rreeaadd() interface.
     The general process is to read struct archive_entry objects from an ar-
     chive, then write those objects to a struct archive object created using
     the aarrcchhiivvee__wwrriittee__ddiisskk() family functions.  This interface is deliber-
     ately very similar to the aarrcchhiivvee__wwrriittee() interface used to write objects
     to a streaming archive.

     aarrcchhiivvee__wwrriittee__ddiisskk__nneeww()
             Allocates and initializes a struct archive object suitable for
             writing objects to disk.

     aarrcchhiivvee__wwrriittee__ddiisskk__sseett__sskkiipp__ffiillee()
             Records the device and inode numbers of a file that should not be
             overwritten.  This is typically used to ensure that an extraction
             process does not overwrite the archive from which objects are
             being read.  This capability is technically unnecessary but can
             be a significant performance optimization in practice.

     aarrcchhiivvee__wwrriittee__ddiisskk__sseett__ooppttiioonnss()
             The options field consists of a bitwise OR of one or more of the
             following values:
             AARRCCHHIIVVEE__EEXXTTRRAACCTT__OOWWNNEERR
                     The user and group IDs should be set on the restored
                     file.  By default, the user and group IDs are not
                     restored.
             AARRCCHHIIVVEE__EEXXTTRRAACCTT__PPEERRMM
                     Full permissions (including SGID, SUID, and sticky bits)
                     should be restored exactly as specified, without obeying
                     the current umask.  Note that SUID and SGID bits can only
                     be restored if the user and group ID of the object on
                     disk are correct.  If AARRCCHHIIVVEE__EEXXTTRRAACCTT__OOWWNNEERR is not speci-
                     fied, then SUID and SGID bits will only be restored if
                     the default user and group IDs of newly-created objects
                     on disk happen to match those specified in the archive
                     entry.  By default, only basic permissions are restored,
                     and umask is obeyed.
             AARRCCHHIIVVEE__EEXXTTRRAACCTT__TTIIMMEE
                     The timestamps (mtime, ctime, and atime) should be
                     restored.  By default, they are ignored.  Note that
                     restoring of atime is not currently supported.
             AARRCCHHIIVVEE__EEXXTTRRAACCTT__NNOO__OOVVEERRWWRRIITTEE
                     Existing files on disk will not be overwritten.  By
                     default, existing regular files are truncated and over-
                     written; existing directories will have their permissions
                     updated; other pre-existing objects are unlinked and
                     recreated from scratch.
             AARRCCHHIIVVEE__EEXXTTRRAACCTT__UUNNLLIINNKK
                     Existing files on disk will be unlinked before any
                     attempt to create them.  In some cases, this can prove to
                     be a significant performance improvement.  By default,
                     existing files are truncated and rewritten, but the file
                     is not recreated.  In particular, the default behavior
                     does not break existing hard links.
             AARRCCHHIIVVEE__EEXXTTRRAACCTT__AACCLL
                     Attempt to restore ACLs.  By default, extended ACLs are
                     ignored.
             AARRCCHHIIVVEE__EEXXTTRRAACCTT__FFFFLLAAGGSS
                     Attempt to restore extended file flags.  By default, file
                     flags are ignored.
             AARRCCHHIIVVEE__EEXXTTRRAACCTT__XXAATTTTRR
                     Attempt to restore POSIX.1e extended attributes.  By
                     default, they are ignored.
             AARRCCHHIIVVEE__EEXXTTRRAACCTT__SSEECCUURREE__SSYYMMLLIINNKKSS
                     Refuse to extract any object whose final location would
                     be altered by a symlink on disk.  This is intended to
                     help guard against a variety of mischief caused by ar-
                     chives that (deliberately or otherwise) extract files
                     outside of the current directory.  The default is not to
                     perform this check.  If AARRCCHHIIVVEE__EEXXTTRRAACCTT__UUNNLLIINNKK is speci-
                     fied together with this option, the library will remove
                     any intermediate symlinks it finds and return an error
                     only if such symlink could not be removed.
             AARRCCHHIIVVEE__EEXXTTRRAACCTT__SSEECCUURREE__NNOODDOOTTDDOOTT
                     Refuse to extract a path that contains a _._. element any-
                     where within it.  The default is to not refuse such
                     paths.  Note that paths ending in _._. always cause an
                     error, regardless of this flag.
             AARRCCHHIIVVEE__EEXXTTRRAACCTT__SSEECCUURREE__NNOOAABBSSOOLLUUTTEEPPAATTHHSS
                     Refuse to extract an absolute path.  The default is to
                     not refuse such paths.
             AARRCCHHIIVVEE__EEXXTTRRAACCTT__SSPPAARRSSEE
                     Scan data for blocks of NUL bytes and try to recreate
                     them with holes.  This results in sparse files, indepen-
                     dent of whether the archive format supports or uses them.
             AARRCCHHIIVVEE__EEXXTTRRAACCTT__CCLLEEAARR__NNOOCCHHAANNGGEE__FFFFLLAAGGSS
                     Before removing a file system object prior to replacing
                     it, clear platform-specific file flags which might pre-
                     vent its removal.

     aarrcchhiivvee__wwrriittee__ddiisskk__sseett__ggrroouupp__llooookkuupp(),
             aarrcchhiivvee__wwrriittee__ddiisskk__sseett__uusseerr__llooookkuupp()
             The struct archive_entry objects contain both names and ids that
             can be used to identify users and groups.  These names and ids
             describe the ownership of the file itself and also appear in ACL
             lists.  By default, the library uses the ids and ignores the
             names, but this can be overridden by registering user and group
             lookup functions.  To register, you must provide a lookup func-
             tion which accepts both a name and id and returns a suitable id.
             You may also provide a void * pointer to a private data structure
             and a cleanup function for that data.  The cleanup function will
             be invoked when the struct archive object is destroyed.

     aarrcchhiivvee__wwrriittee__ddiisskk__sseett__ssttaannddaarrdd__llooookkuupp()
             This convenience function installs a standard set of user and
             group lookup functions.  These functions use getpwnam(3) and
             getgrnam(3) to convert names to ids, defaulting to the ids if the
             names cannot be looked up.  These functions also implement a sim-
             ple memory cache to reduce the number of calls to getpwnam(3) and
             getgrnam(3).

     aarrcchhiivvee__wwrriittee__hheeaaddeerr()
             Build and write a header using the data in the provided struct
             archive_entry structure.  See archive_entry(3) for information on
             creating and populating struct archive_entry objects.

     aarrcchhiivvee__wwrriittee__ddaattaa()
             Write data corresponding to the header just written.  Returns
             number of bytes written or -1 on error.

     aarrcchhiivvee__wwrriittee__ddaattaa__bblloocckk()
             Write data corresponding to the header just written.  This is
             like aarrcchhiivvee__wwrriittee__ddaattaa() except that it performs a seek on the
             file being written to the specified offset before writing the
             data.  This is useful when restoring sparse files from archive
             formats that support sparse files.  Returns number of bytes writ-
             ten or -1 on error.  (Note: This is currently not supported for
             archive_write handles, only for archive_write_disk handles.)

     aarrcchhiivvee__wwrriittee__ffiinniisshh__eennttrryy()
             Close out the entry just written.  Ordinarily, clients never need
             to call this, as it is called automatically by
             aarrcchhiivvee__wwrriittee__nneexxtt__hheeaaddeerr() and aarrcchhiivvee__wwrriittee__cclloossee() as needed.
             However, some file attributes are written to disk only after the
             file is closed, so this can be necessary if you need to work with
             the file on disk right away.

     aarrcchhiivvee__wwrriittee__cclloossee()
             Set any attributes that could not be set during the initial
             restore.  For example, directory timestamps are not restored ini-
             tially because restoring a subsequent file would alter that time-
             stamp.  Similarly, non-writable directories are initially created
             with write permissions (so that their contents can be restored).
             The aarrcchhiivvee__wwrriittee__ddiisskk__nneeww library maintains a list of all such
             deferred attributes and sets them when this function is invoked.

     aarrcchhiivvee__wwrriittee__ffiinniisshh()
             This is a deprecated synonym for aarrcchhiivvee__wwrriittee__ffrreeee().

     aarrcchhiivvee__wwrriittee__ffrreeee()
             Invokes aarrcchhiivvee__wwrriittee__cclloossee() if it was not invoked manually,
             then releases all resources.
     More information about the _s_t_r_u_c_t _a_r_c_h_i_v_e object and the overall design
     of the library can be found in the libarchive(3) overview.  Many of these
     functions are also documented under archive_write(3).

RREETTUURRNN VVAALLUUEESS
     Most functions return AARRCCHHIIVVEE__OOKK (zero) on success, or one of several
     non-zero error codes for errors.  Specific error codes include:
     AARRCCHHIIVVEE__RREETTRRYY for operations that might succeed if retried, AARRCCHHIIVVEE__WWAARRNN
     for unusual conditions that do not prevent further operations, and
     AARRCCHHIIVVEE__FFAATTAALL for serious errors that make remaining operations impossi-
     ble.

     aarrcchhiivvee__wwrriittee__ddiisskk__nneeww() returns a pointer to a newly-allocated struct
     archive object.

     aarrcchhiivvee__wwrriittee__ddaattaa() returns a count of the number of bytes actually
     written, or -1 on error.

EERRRROORRSS
     Detailed error codes and textual descriptions are available from the
     aarrcchhiivvee__eerrrrnnoo() and aarrcchhiivvee__eerrrroorr__ssttrriinngg() functions.

SSEEEE AALLSSOO
     archive_read(3), archive_write(3), tar(1), libarchive(3)

HHIISSTTOORRYY
     The lliibbaarrcchhiivvee library first appeared in FreeBSD 5.3.  The
     aarrcchhiivvee__wwrriittee__ddiisskk interface was added to lliibbaarrcchhiivvee 22..00 and first
     appeared in FreeBSD 6.3.

AAUUTTHHOORRSS
     The lliibbaarrcchhiivvee library was written by Tim Kientzle <kientzle@acm.org>.

BBUUGGSS
     Directories are actually extracted in two distinct phases.  Directories
     are created during aarrcchhiivvee__wwrriittee__hheeaaddeerr(), but final permissions are not
     set until aarrcchhiivvee__wwrriittee__cclloossee().  This separation is necessary to cor-
     rectly handle borderline cases such as a non-writable directory contain-
     ing files, but can cause unexpected results.  In particular, directory
     permissions are not fully restored until the archive is closed.  If you
     use chdir(2) to change the current directory between calls to
     aarrcchhiivvee__rreeaadd__eexxttrraacctt() or before calling aarrcchhiivvee__rreeaadd__cclloossee(), you may
     confuse the permission-setting logic with the result that directory per-
     missions are restored incorrectly.

     The library attempts to create objects with filenames longer than
     PPAATTHH__MMAAXX by creating prefixes of the full path and changing the current
     directory.  Currently, this logic is limited in scope; the fixup pass
     does not work correctly for such objects and the symlink security check
     option disables the support for very long pathnames.

     Restoring the path _a_a_/_._._/_b_b does create each intermediate directory.  In
     particular, the directory _a_a is created as well as the final object _b_b.
     In theory, this can be exploited to create an entire directory hierarchy
     with a single request.  Of course, this does not work if the
     AARRCCHHIIVVEE__EEXXTTRRAACCTT__NNOODDOOTTDDOOTT option is specified.

     Implicit directories are always created obeying the current umask.
     Explicit objects are created obeying the current umask unless
     AARRCCHHIIVVEE__EEXXTTRRAACCTT__PPEERRMM is specified, in which case they current umask is
     ignored.

     SGID and SUID bits are restored only if the correct user and group could
     be set.  If AARRCCHHIIVVEE__EEXXTTRRAACCTT__OOWWNNEERR is not specified, then no attempt is
     made to set the ownership.  In this case, SGID and SUID bits are restored
     only if the user and group of the final object happen to match those
     specified in the entry.

     The ``standard'' user-id and group-id lookup functions are not the
     defaults because getgrnam(3) and getpwnam(3) are sometimes too large for
     particular applications.  The current design allows the application
     author to use a more compact implementation when appropriate.

     There should be a corresponding aarrcchhiivvee__rreeaadd__ddiisskk interface that walks a
     directory hierarchy and returns archive entry objects.

BSD                            February 2, 2012                            BSD
