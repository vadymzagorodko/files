ARCHIVE_READ_DISK(3)     BSD Library Functions Manual     ARCHIVE_READ_DISK(3)

NNAAMMEE
     aarrcchhiivvee__rreeaadd__ddiisskk__nneeww, aarrcchhiivvee__rreeaadd__ddiisskk__sseett__ssyymmlliinnkk__llooggiiccaall,
     aarrcchhiivvee__rreeaadd__ddiisskk__sseett__ssyymmlliinnkk__pphhyyssiiccaall,
     aarrcchhiivvee__rreeaadd__ddiisskk__sseett__ssyymmlliinnkk__hhyybbrriidd, aarrcchhiivvee__rreeaadd__ddiisskk__eennttrryy__ffrroomm__ffiillee,
     aarrcchhiivvee__rreeaadd__ddiisskk__ggnnaammee, aarrcchhiivvee__rreeaadd__ddiisskk__uunnaammee,
     aarrcchhiivvee__rreeaadd__ddiisskk__sseett__uunnaammee__llooookkuupp, aarrcchhiivvee__rreeaadd__ddiisskk__sseett__ggnnaammee__llooookkuupp,
     aarrcchhiivvee__rreeaadd__ddiisskk__sseett__ssttaannddaarrdd__llooookkuupp, aarrcchhiivvee__rreeaadd__cclloossee,
     aarrcchhiivvee__rreeaadd__ffiinniisshh, aarrcchhiivvee__rreeaadd__ffrreeee -- functions for reading objects
     from disk

LLIIBBRRAARRYY
     Streaming Archive Library (libarchive, -larchive)

SSYYNNOOPPSSIISS
     ##iinncclluuddee <<aarrcchhiivvee..hh>>

     _s_t_r_u_c_t _a_r_c_h_i_v_e _*
     aarrcchhiivvee__rreeaadd__ddiisskk__nneeww(_v_o_i_d);

     _i_n_t
     aarrcchhiivvee__rreeaadd__ddiisskk__sseett__ssyymmlliinnkk__llooggiiccaall(_s_t_r_u_c_t _a_r_c_h_i_v_e _*);

     _i_n_t
     aarrcchhiivvee__rreeaadd__ddiisskk__sseett__ssyymmlliinnkk__pphhyyssiiccaall(_s_t_r_u_c_t _a_r_c_h_i_v_e _*);

     _i_n_t
     aarrcchhiivvee__rreeaadd__ddiisskk__sseett__ssyymmlliinnkk__hhyybbrriidd(_s_t_r_u_c_t _a_r_c_h_i_v_e _*);

     _c_o_n_s_t _c_h_a_r _*
     aarrcchhiivvee__rreeaadd__ddiisskk__ggnnaammee(_s_t_r_u_c_t _a_r_c_h_i_v_e _*, _g_i_d___t);

     _c_o_n_s_t _c_h_a_r _*
     aarrcchhiivvee__rreeaadd__ddiisskk__uunnaammee(_s_t_r_u_c_t _a_r_c_h_i_v_e _*, _u_i_d___t);

     _i_n_t
     aarrcchhiivvee__rreeaadd__ddiisskk__sseett__ggnnaammee__llooookkuupp(_s_t_r_u_c_t _a_r_c_h_i_v_e _*, _v_o_i_d _*,
         _c_o_n_s_t _c_h_a_r _*_(_*_l_o_o_k_u_p_)_(_v_o_i_d _*_, _g_i_d___t_), _v_o_i_d _(_*_c_l_e_a_n_u_p_)_(_v_o_i_d _*_));

     _i_n_t
     aarrcchhiivvee__rreeaadd__ddiisskk__sseett__uunnaammee__llooookkuupp(_s_t_r_u_c_t _a_r_c_h_i_v_e _*, _v_o_i_d _*,
         _c_o_n_s_t _c_h_a_r _*_(_*_l_o_o_k_u_p_)_(_v_o_i_d _*_, _u_i_d___t_), _v_o_i_d _(_*_c_l_e_a_n_u_p_)_(_v_o_i_d _*_));

     _i_n_t
     aarrcchhiivvee__rreeaadd__ddiisskk__sseett__ssttaannddaarrdd__llooookkuupp(_s_t_r_u_c_t _a_r_c_h_i_v_e _*);

     _i_n_t
     aarrcchhiivvee__rreeaadd__ddiisskk__eennttrryy__ffrroomm__ffiillee(_s_t_r_u_c_t _a_r_c_h_i_v_e _*,
         _s_t_r_u_c_t _a_r_c_h_i_v_e___e_n_t_r_y _*, _i_n_t _f_d, _c_o_n_s_t _s_t_r_u_c_t _s_t_a_t _*);

     _i_n_t
     aarrcchhiivvee__rreeaadd__cclloossee(_s_t_r_u_c_t _a_r_c_h_i_v_e _*);

     _i_n_t
     aarrcchhiivvee__rreeaadd__ffiinniisshh(_s_t_r_u_c_t _a_r_c_h_i_v_e _*);

     _i_n_t
     aarrcchhiivvee__rreeaadd__ffrreeee(_s_t_r_u_c_t _a_r_c_h_i_v_e _*);

DDEESSCCRRIIPPTTIIOONN
     These functions provide an API for reading information about objects on
     disk.  In particular, they provide an interface for populating struct
     archive_entry objects.

     aarrcchhiivvee__rreeaadd__ddiisskk__nneeww()
             Allocates and initializes a struct archive object suitable for
             reading object information from disk.

     aarrcchhiivvee__rreeaadd__ddiisskk__sseett__ssyymmlliinnkk__llooggiiccaall(),
             aarrcchhiivvee__rreeaadd__ddiisskk__sseett__ssyymmlliinnkk__pphhyyssiiccaall(),
             aarrcchhiivvee__rreeaadd__ddiisskk__sseett__ssyymmlliinnkk__hhyybbrriidd()
             This sets the mode used for handling symbolic links.  The
             ``logical'' mode follows all symbolic links.  The ``physical''
             mode does not follow any symbolic links.  The ``hybrid'' mode
             currently behaves identically to the ``logical'' mode.

     aarrcchhiivvee__rreeaadd__ddiisskk__ggnnaammee(), aarrcchhiivvee__rreeaadd__ddiisskk__uunnaammee()
             Returns a user or group name given a gid or uid value.  By
             default, these always return a NULL string.

     aarrcchhiivvee__rreeaadd__ddiisskk__sseett__ggnnaammee__llooookkuupp(),
             aarrcchhiivvee__rreeaadd__ddiisskk__sseett__uunnaammee__llooookkuupp()
             These allow you to override the functions used for user and group
             name lookups.  You may also provide a void * pointer to a private
             data structure and a cleanup function for that data.  The cleanup
             function will be invoked when the struct archive object is
             destroyed or when new lookup functions are registered.

     aarrcchhiivvee__rreeaadd__ddiisskk__sseett__ssttaannddaarrdd__llooookkuupp()
             This convenience function installs a standard set of user and
             group name lookup functions.  These functions use getpwuid(3) and
             getgrgid(3) to convert ids to names, defaulting to NULL if the
             names cannot be looked up.  These functions also implement a sim-
             ple memory cache to reduce the number of calls to getpwuid(3) and
             getgrgid(3).

     aarrcchhiivvee__rreeaadd__ddiisskk__eennttrryy__ffrroomm__ffiillee()
             Populates a struct archive_entry object with information about a
             particular file.  The archive_entry object must have already been
             created with archive_entry_new(3) and at least one of the source
             path or path fields must already be set.  (If both are set, the
             source path will be used.)

             Information is read from disk using the path name from the struct
             archive_entry object.  If a file descriptor is provided, some
             information will be obtained using that file descriptor, on plat-
             forms that support the appropriate system calls.

             If a pointer to a struct stat is provided, information from that
             structure will be used instead of reading from the disk where
             appropriate.  This can provide performance benefits in scenarios
             where struct stat information has already been read from the disk
             as a side effect of some other operation.  (For example, direc-
             tory traversal libraries often provide this information.)

             Where necessary, user and group ids are converted to user and
             group names using the currently registered lookup functions
             above.  This affects the file ownership fields and ACL values in
             the struct archive_entry object.

     aarrcchhiivvee__rreeaadd__cclloossee()
             Does nothing for archive_read_disk handles.

     aarrcchhiivvee__rreeaadd__ffiinniisshh()
             This is a deprecated synonym for aarrcchhiivvee__rreeaadd__ffrreeee().

     aarrcchhiivvee__rreeaadd__ffrreeee()
             Invokes aarrcchhiivvee__rreeaadd__cclloossee() if it was not invoked manually, then
             releases all resources.
     More information about the _s_t_r_u_c_t _a_r_c_h_i_v_e object and the overall design
     of the library can be found in the libarchive(3) overview.

EEXXAAMMPPLLEE
     The following illustrates basic usage of the library by showing how to
     use it to copy an item on disk into an archive.

           void
           file_to_archive(struct archive *a, const char *name)
           {
             char buff[8192];
             size_t bytes_read;
             struct archive *ard;
             struct archive_entry *entry;
             int fd;

             ard = archive_read_disk_new();
             archive_read_disk_set_standard_lookup(ard);
             entry = archive_entry_new();
             fd = open(name, O_RDONLY);
             if (fd < 0)
                return;
             archive_entry_copy_pathname(entry, name);
             archive_read_disk_entry_from_file(ard, entry, fd, NULL);
             archive_write_header(a, entry);
             while ((bytes_read = read(fd, buff, sizeof(buff))) > 0)
               archive_write_data(a, buff, bytes_read);
             archive_write_finish_entry(a);
             archive_read_free(ard);
             archive_entry_free(entry);
           }

RREETTUURRNN VVAALLUUEESS
     Most functions return AARRCCHHIIVVEE__OOKK (zero) on success, or one of several
     negative error codes for errors.  Specific error codes include:
     AARRCCHHIIVVEE__RREETTRRYY for operations that might succeed if retried, AARRCCHHIIVVEE__WWAARRNN
     for unusual conditions that do not prevent further operations, and
     AARRCCHHIIVVEE__FFAATTAALL for serious errors that make remaining operations impossi-
     ble.

     aarrcchhiivvee__rreeaadd__ddiisskk__nneeww() returns a pointer to a newly-allocated struct
     archive object or NULL if the allocation failed for any reason.

     aarrcchhiivvee__rreeaadd__ddiisskk__ggnnaammee() and aarrcchhiivvee__rreeaadd__ddiisskk__uunnaammee() return const char
     * pointers to the textual name or NULL if the lookup failed for any rea-
     son.  The returned pointer points to internal storage that may be reused
     on the next call to either of these functions; callers should copy the
     string if they need to continue accessing it.

EERRRROORRSS
     Detailed error codes and textual descriptions are available from the
     aarrcchhiivvee__eerrrrnnoo() and aarrcchhiivvee__eerrrroorr__ssttrriinngg() functions.

SSEEEE AALLSSOO
     archive_read(3), archive_util(3), archive_write(3),
     archive_write_disk(3), tar(1), libarchive(3)

HHIISSTTOORRYY
     The lliibbaarrcchhiivvee library first appeared in FreeBSD 5.3.  The
     aarrcchhiivvee__rreeaadd__ddiisskk interface was added to lliibbaarrcchhiivvee 22..66 and first
     appeared in FreeBSD 8.0.

AAUUTTHHOORRSS
     The lliibbaarrcchhiivvee library was written by Tim Kientzle
     <kientzle@FreeBSD.org>.

BBUUGGSS
     The ``standard'' user name and group name lookup functions are not the
     defaults because getgrgid(3) and getpwuid(3) are sometimes too large for
     particular applications.  The current design allows the application
     author to use a more compact implementation when appropriate.

     The full list of metadata read from disk by
     aarrcchhiivvee__rreeaadd__ddiisskk__eennttrryy__ffrroomm__ffiillee() is necessarily system-dependent.

     The aarrcchhiivvee__rreeaadd__ddiisskk__eennttrryy__ffrroomm__ffiillee() function reads as much informa-
     tion as it can from disk.  Some method should be provided to limit this
     so that clients who do not need ACLs, for instance, can avoid the extra
     work needed to look up such information.

     This API should provide a set of methods for walking a directory tree.
     That would make it a direct parallel of the archive_read(3) API.  When
     such methods are implemented, the ``hybrid'' symbolic link mode will make
     sense.

BSD                            December 30, 2016                           BSD
